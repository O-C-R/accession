/*

OCR / MoMA Server (node.js)
The Office For Creative Research
June, 2016

*/

var rita = require('rita');
var lev = require('levenshtein');

var tol = 0.1;

//Load NLP-ed data
var artistsJson = require(__base + 'data/ArtistsNLP');
var artworksJson = require(__base + 'data/ArtworksNLP');

//Match

function getWordMatches(pattern, mode, extension, weights, max, imagesOnly) {

	var weightList = weights.split(",");
	pattern = rita.RiTa.trim(pattern);
	
	var returns = [];

	var corpus = (mode == "artists" ? artistsJson:artworksJson);

	var matchList = rita.RiTa.getPosTags(pattern);
	var match = matchList.join(" ");
	var partsOfSpeech = rita.RiTa.getPosTags(pattern).join(" ");
	var stresses = rita.RiTa.getStresses(pattern);
	var syllables = rita.RiTa.getSyllables(pattern);
	var syllableCount = countSyllables(stresses);

	//Go through the corpus and extract candidates that have the right number of words
	var candidates = [];
	var tokenMap = {};
	console.log("CHECKING AGAINST " + corpus.length + " CANDIDATES.");
	for(var i = 0; i < corpus.length; i++) {
		var candidate = corpus[i];
		var testAgainst = rita.RiTa.trim(corpus[i].NLP.NLPString); 

		if (pattern.split(" ").length  + parseInt(extension) == testAgainst.split(" ").length && pattern != testAgainst && (!imagesOnly || corpus[i].ThumbnailURL != null)) {
			candidates.push(corpus[i]); 
		}
	}

	console.log("FOUND " + candidates.length + " CANDIDATES.");

	//Now go through these candidates and get the piece that matches; also score
	for (var i = 0; i < candidates.length; i++) {


		//Levenshtein distances, will be smaller the closer the strings are together
		//We'll normalize them to make them range from 0 - 1;
		var patternLev = lev(pattern, candidates[i].NLP.NLPString) / Math.max(pattern.length, candidates[i].NLP.NLPString.length) ;
		var posLev = lev(partsOfSpeech, candidates[i].NLP.PartsOfSpeech.join(" ")) / Math.max(partsOfSpeech.length, candidates[i].NLP.PartsOfSpeech.join(" ").length);
		var stressLev = lev(stresses, candidates[i].NLP.Stresses) / Math.max(stresses.length, candidates[i].NLP.Stresses.length);
		var syllablesLev = lev(syllables, candidates[i].NLP.Syllables) / Math.max(syllables.length, candidates[i].NLP.Syllables.length);


		//We want our score to be higher == better, so let's flip the Lev distances, and then multiply them by the weights
		var score = ((1.0 - patternLev) * weightList[0]) + ((1.0 - posLev) * weightList[1]) + ((1.0 - stressLev) * weightList[2]) + ((1.0 - syllablesLev) * weightList[3]);

		returns.push({'score':score, 'candidate':candidates[i]});

	}

	returns.sort(function(a,b) { return parseFloat(b.score) - parseFloat(a.score) } );

	if (max) {
		returns = returns.slice(0, max);
	}

	return({'query':pattern, 'corpus':mode, 'results':returns});


}

function countSyllables(s) {
	var syllables = 0;
  	var sswords = s.split(" ");
	 for (var i = 0; i < sswords.length; i++) {
	    syllables += sswords[i].split("/").length;
	 }
	 return(syllables);

}

function computeEditDistance( s1,  s2) {
  s1 = s1.toLowerCase();
  s2 = s2.toLowerCase();

  var costs = [];
  for (var i = 0; i <= s1.length; i++) {
    var lastValue = i;
    for (var j = 0; j <= s2.length; j++) {
      if (i == 0)
        costs[j] = j;
      else {
        if (j > 0) {
          var newValue = costs[j - 1];
          if (s1.charAt(i - 1) != s2.charAt(j - 1))
          newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
          costs[j - 1] = lastValue;
          lastValue = newValue;
        }
      }
    }
    if (i > 0)
      costs[s2.length] = lastValue;
  }
  return costs[s2.length];
}

//Hook for node
module.exports.getWordMatches = getWordMatches;